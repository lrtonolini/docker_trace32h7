#!/usr/bin/env bash

###################################################################################
# TRACE32 udev rules installer for Lauterbach USB devices.                        #
# Author: MBU FRA AME                                                             #
# Copyright: (c) 1989-2023 Lauterbach GmbH, licensed for use with TRACE32(R) only #
###################################################################################

# @getoptions
parser_definition() {
  setup   REST help:usage -- "Usage: setup_udevrules.sh [options]... [arguments]..." ''
  msg -- 'Options:'
  flag    NONINTERACTIVE     --non-interactive                                       -- "non-interactive mode"
  flag    ROOTCALL           --rootcall
  param   USER            -u --user                                                  -- "assign USER=PARAM e.g. $(id --user --name)"
  param   GROUP           -g --group                                                 -- "assign GROUP=PARAM e.g. plugdev"
  param   MODE            -m --mode init:'MODE="0666"' validate:validateMode         -- "assign MODE=PARAM e.g. 0666"
  param   RULES           -r --rules pattern:'1 | 2 | "*" | all'                     -- "'all' all rules, '1' only Lauterbach devices, '2' only USB debug targets"
  option  USBID              --usb-id on:'../t32usb_id'                              -- "enable persistent rules using t32usb_id"
  disp    :usage          -h --help
}
# @end

# @gengetoptions parser -i parser_definition parse
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
NONINTERACTIVE=''
ROOTCALL=''
USER=''
GROUP=''
MODE="0666"
RULES=''
USBID=''
REST=''
parse() {
  OPTIND=$(($#+1))
  while OPTARG= && [ $# -gt 0 ]; do
    case $1 in
      --?*=*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
        ;;
      --no-*|--without-*) unset OPTARG ;;
      -[ugmr]?*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%"${OPTARG#??}"}" "${OPTARG#??}"' ${1+'"$@"'}
        ;;
      -[h]?*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
        OPTARG= ;;
    esac
    case $1 in
      '--non-interactive')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        NONINTERACTIVE="$OPTARG"
        ;;
      '--rootcall')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        ROOTCALL="$OPTARG"
        ;;
      '-u'|'--user')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        USER="$OPTARG"
        shift ;;
      '-g'|'--group')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        GROUP="$OPTARG"
        shift ;;
      '-m'|'--mode')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        validateMode || { set -- validateMode:$? "$1" validateMode; break; }
        MODE="$OPTARG"
        shift ;;
      '-r'|'--rules')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        case $OPTARG in 1 | 2 | "*" | all) ;;
          *) set "pattern:1 | 2 | "*" | all" "$1"; break
        esac
        RULES="$OPTARG"
        shift ;;
      '--usb-id')
        set -- "$1" "$@"
        [ ${OPTARG+x} ] && {
          case $1 in --no-*|--without-*) set "noarg" "${1%%\=*}"; break; esac
          [ "${OPTARG:-}" ] && { shift; OPTARG=$2; } || OPTARG='../t32usb_id'
        } || OPTARG=''
        USBID="$OPTARG"
        shift ;;
      '-h'|'--help')
        usage
        exit 0 ;;
      --)
        shift
        while [ $# -gt 0 ]; do
          REST="${REST} \"\${$(($OPTIND-$#))}\""
          shift
        done
        break ;;
      [-]?*) set "unknown" "$1"; break ;;
      *)
        REST="${REST} \"\${$(($OPTIND-$#))}\""
    esac
    shift
  done
  [ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
  case $1 in
    unknown) set "Unrecognized option: $2" "$@" ;;
    noarg) set "Does not allow an argument: $2" "$@" ;;
    required) set "Requires an argument: $2" "$@" ;;
    pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
    notcmd) set "Not a command: $2" "$@" ;;
    *) set "Validation error ($1): $2" "$@"
  esac
  echo "$1" >&2
  exit 1
}
usage() {
cat<<'GETOPTIONSHERE'
Usage: setup_udevrules.sh [options]... [arguments]...

Options:
      --non-interactive       non-interactive mode
      --rootcall
  -u, --user USER             assign USER=PARAM e.g. amerkle
  -g, --group GROUP           assign GROUP=PARAM e.g. plugdev
  -m, --mode MODE             assign MODE=PARAM e.g. 0666
  -r, --rules RULES           'all' all rules, '1' only Lauterbach devices, '2' only USB debug targets
      --usb-id[=USBID]        enable persistent rules using t32usb_id
  -h, --help
GETOPTIONSHERE
}
# Generated by getoptions (END)
# @end
userPrompt () {
	local prompt ans
	prompt="${1}"
	if [ -n "$ZSH_VERSION" ]; then
		read "?      $prompt " ans
	else
		read -p "      $prompt " ans
	fi
	echo "$ans"
}
validateMode() {
  case $OPTARG in ([0][0-7][0-7][0-7]) return 0; esac
  return 1
}
rulesReplaceKeys () {
  local RULESDFILE
  local THISUSER
  RULESDFILE="$1"
  if [ -n "${MODE}" ]; then
    sed -i "s/\(MODE\s*:=\).*/\1\"${MODE}\"/g" "${RULESDFILE}"
    sed -i 's/^#MODE:=/MODE:=/g' "${RULESDFILE}"
  fi
  if [ -n "${USER}" ]; then
    sed -i "s/\(USER\s*:=\).*/\1\"${USER}\"/g" "${RULESDFILE}"
    sed -i 's/^#USER:=/USER:=/g' "${RULESDFILE}"
  fi
  if [ -n "${GROUP}" ]; then
    sed -i "s/\(GROUP\s*:=\).*/\1\"${GROUP}\"/g" "${RULESDFILE}"
    sed -i 's/^#GROUP:=/GROUP:=/g' "${RULESDFILE}"
  fi
  if [ -n "${USBID}" ]; then
    sed -i "s%<path_to>/t32usb_id%${USBID_ABS}%g" "${RULESDFILE}"
  fi
  if [ -n "${T32INSTALLUDEVUSER}" ]; then
    THISUSER="${T32INSTALLUDEVUSER} via sudo"
  else
    THISUSER=$(id --user --name)
  fi
  sed -i '2i # Generated using setup_udevrules.sh $Revision: 163773 $ on <install_date> by <install_user>' "${RULESDFILE}"
  sed -i "s/<install_date>/$(date)/g" "${RULESDFILE}"
  sed -i "s/<install_user>/${THISUSER}/g" "${RULESDFILE}"
  return
}
elevateRoot () {
  # Check permissions for the udev rules directory
  if [ -w "/etc/udev/rules.d" ]; then
    return
  fi

  echo "#T32: No write permission for \"/etc/udev/rules.d\"."
  if [ -n "${NONINTERACTIVE}" ]; then
    exit 1
  fi

  if [ "$EUID" -eq 0 ]; then
    # root doesn't have write access
    echo "#T32 ERROR: Cancelling installation of udev rules (missing permissions)."
    echo "#    Please install udev rules manually to get access to USB devices."
    exit 1
  fi

  local TRIES
  local RETVAL
  local CMDLINE
  local THISUSER
  TRIES=0
  THISUSER=$(id --user --name)
  
  #Call the script as root to install udev rules
  if [ -z "$(which sudo 2>/dev/null)" ]; then
    #if sudo is not available use the su fallback method
    while true; do
      let TRIES++
      echo "#T32: Do you want to run this script as root?"
      ans=$(userPrompt "(Yes/No)")
      case $ans in
        [Yy]* )
          CMDLINE="T32INSTALLUDEVROOTCALL=1 T32INSTALLUDEVUSER=${THISUSER} \"${SCRIPTDIR}/${SCRIPTNAME}\" ${ARGV[@]}"
          su -m -c "${CMDLINE}"
          RETVAL=$?
          if [ ${RETVAL} -eq 0 ] || [ ${RETVAL} -eq 130 ]; then
            exit ${RETVAL}
          elif [ ${TRIES} -gt 3 ]; then
            break
          else
            echo "Sorry, try again"
          fi
          ;;
        [Nn]* )
          echo "#T32: Installation of udev rules aborted by user (no root access)."$'\n      Please install udev rules manually to get access to USB devices.'
          break
          ;;
        * )
          echo "#T32: Please answer \"Yes\" or \"No\"."
          ;;
      esac
    done
  else
    while true; do
      let TRIES++
      echo "#T32: Do you want to run this script as root?"
      ans=$(userPrompt "(Yes/No)")
      case $ans in
        [Yy]* )
          CMDLINE="T32INSTALLUDEVROOTCALL=1 T32INSTALLUDEVUSER=${THISUSER} \"${SCRIPTDIR}/${SCRIPTNAME}\" ${ARGV[@]}"
          sudo su -m -c "${CMDLINE}"
          RETVAL=$?
          if [ ${RETVAL} -eq 0 ] || [ ${RETVAL} -eq 130 ]; then
            exit ${RETVAL}
          elif [ ${TRIES} -gt 3 ]; then
            break
          else
            echo "Sorry, try again"
          fi
          ;;
        [Nn]* )
          echo "#T32: Installation of udev rules aborted by user (no root access)."$'\n      Please install udev rules manually to get access to USB devices.'
          exit 0
          ;;
        * )
          echo "#T32: Please answer \"Yes\" or \"No\"."
          ;;
      esac
    done
  fi
  if [ $TRIES -gt 3 ]; then
    echo "#T32 ERROR: Could not get root access, cancelling installation of udev rules."
    echo "#    Please install udev rules manually to get access to USB devices."
  fi
  exit 1
}

SCRIPTDIR=$( cd "$( dirname "$0" )" && pwd )
SCRIPTNAME=$( basename "$( readlink -fn "$0" )" )
LTBUDEVRULEFILE="10-lauterbach.rules"
TRGTUDEVRULEFILE="10-lauterbach_target.rules"
ARGV=("$@")

parse "$@"

if [ -n "${REST}" ]; then
  eval "set -- $REST"
  echo "#T32: invalid argument '$@'"
  exit 1
fi
if [ -n "${NONINTERACTIVE}" ] && [ -z "${RULES}" ]; then
  echo "#T32: non-interactive mode requires -r/--rules RULES"
  exit 1
fi
if [ -n "${USBID}" ]; then
  USBID_ABS=$( cd "${SCRIPTDIR}" && realpath "${USBID}" )
  if [ ! -e "${USBID}" ]; then
    echo "#T32: file '${USBID}' does not exist"
    exit 1
  fi
  if [ ! -x "${USBID}" ]; then
    echo "#T32: file '${USBID}' is not exectuable use e.g. chmod +x"
    exit 1
  fi
fi

if [ -z "${T32INSTALLUDEVROOTCALL}" ]; then
  echo
  echo "################################################################################"
  echo "#T32: This script installs TRACE32 udev rules for"
  echo "#     - Lauterbach USB devices"
  echo "#       and / or"
  echo "#     - USB debug target devices"
  echo "#     Root privileges are needed to copy the rules file to /etc/udev/rules.d/"
  echo "################################################################################"
fi

# Check existing udev rules folder structure and files
if [ ! -d "${SCRIPTDIR}/kernel_starting_4.14" ] ||
    [ ! -d "${SCRIPTDIR}/kernel_starting_2.6.32" ] ||
    [ ! -f "${SCRIPTDIR}/kernel_starting_4.14/${LTBUDEVRULEFILE}" ] ||
    [ ! -f "${SCRIPTDIR}/kernel_starting_2.6.32/${LTBUDEVRULEFILE}" ] ||
    [ ! -f "${SCRIPTDIR}/kernel_starting_4.14/${TRGTUDEVRULEFILE}" ] ||
    [ ! -f "${SCRIPTDIR}/kernel_starting_2.6.32/${TRGTUDEVRULEFILE}" ]; then
  echo "#T32 ERROR: Script must be executed from the Lauterbach provided udev.conf directory."
  exit 1
fi

# Check permissions for the udev rules directory
# - elevateRoot may not return
elevateRoot

# the real script starts here
FILECOPY=0
case ${RULES} in
  '1' | '2')
    FILECOPY=${RULES}
    ;;
  '*' | 'all')
    FILECOPY=3
    ;;
  * )
    while true; do
      echo "#T32: Do you want to install udev rules for"
      echo "      (1) Lauterbach USB devices (e.g. PowerDebug USB3)"
      echo "      (2) USB debug target devices"
      echo "      (3) Both?"
      ans=$(userPrompt "(1/2/3/Cancel)")
      case $ans in
        [1] ) echo "#T32: Installing udev rules for Lauterbach USB devices."; FILECOPY=1; break;;
        [2] ) echo "#T32: Installing udev rules for USB debug target devices."; FILECOPY=2; break;;
        [3] ) echo "#T32: Installing udev rules for Lauterbach USB devices and USB debug target devices."; FILECOPY=3; break;;
        [Cc]* ) echo "#T32: Installation of udev rules aborted by user."; break;;
        * ) echo "#T32: Please answer \"1\", \"2\",\"3\" or \"Cancel\".";;
      esac
    done
esac

if [ "$FILECOPY" -eq 0 ]; then
  exit 0
fi

# Get kernel number and udev version
KERNVER=$( uname -r | awk -F . '{print $1}' )
KERNMAJ=$( uname -r | awk -F . '{print $2}' )
# KERNMIN=$( uname -r | awk -F . '{print $3}' )
if [ "$FILECOPY" -eq 1 ] || [ "$FILECOPY" -eq 3 ]; then # Ltb USB devices
  CANCEL=0
  if [ -z "${NONINTERACTIVE}" ] && [ -f "/etc/udev/rules.d/${LTBUDEVRULEFILE}" ]; then
    while true; do
      echo "#T32: The udev rule file $LTBUDEVRULEFILE already exists."
      ans=$(userPrompt "Do you want to overwrite and update it? (Yes/No)")
      case $ans in
        [Yy]* ) echo "#T32: Updating udev rules now:"; break;;
        [Nn]* ) echo "#T32: Udev rule overwrite canceled by user."; CANCEL=1; break;;
        * ) echo "#T32: Please answer \"Yes\" or \"No\".";;
      esac
    done
  fi
  if [ ${CANCEL} -eq 0 ]; then
    if { [ "$KERNVER" -lt 4 ]; } || { [ "$KERNVER" -eq 4 ] && [ "$KERNMAJ" -lt 14 ]; } then
      cp -fv "${SCRIPTDIR}/kernel_starting_2.6.32/${LTBUDEVRULEFILE}" "/etc/udev/rules.d"
    else
      cp -fv "${SCRIPTDIR}/kernel_starting_4.14/${LTBUDEVRULEFILE}" "/etc/udev/rules.d"
      rulesReplaceKeys "/etc/udev/rules.d/${LTBUDEVRULEFILE}"
    fi
    echo "#T32: Finished udev rule installation for Lauterbach USB devices."
  fi
fi
if [ "$FILECOPY" -eq 2 ] || [ "$FILECOPY" -eq 3 ]; then # USB debug targets
  CANCEL=0
  if [ -z "${NONINTERACTIVE}" ] && [ -f "/etc/udev/rules.d/${TRGTUDEVRULEFILE}" ]; then
    while true; do
      echo "#T32: The udev rule file $TRGTUDEVRULEFILE already exists."
      ans=$(userPrompt "Do you want to overwrite and update it? (Yes/No)")
      case $ans in
        [Yy]* ) echo "#T32: Updating udev rules now:"; break;;
        [Nn]* ) echo "#T32: Udev rule overwrite canceled by user."; FILECOPYCANCEL=1; break;;
        * ) echo "#T32: Please answer \"Yes\" or \"No\".";;
      esac
    done
  fi
  if [ ${CANCEL} -eq 0 ]; then
    if { [ "$KERNVER" -lt 4 ]; } || { [ "$KERNVER" -eq 4 ] && [ "$KERNMAJ" -lt 14 ]; } then
      cp -fv "$SCRIPTDIR/kernel_starting_2.6.32/${TRGTUDEVRULEFILE}" "/etc/udev/rules.d"
    else
      cp -fv "$SCRIPTDIR/kernel_starting_4.14/${TRGTUDEVRULEFILE}" "/etc/udev/rules.d"
      rulesReplaceKeys "/etc/udev/rules.d/${TRGTUDEVRULEFILE}"
    fi
    echo "#T32: Finished udev rule installation for USB debug target devices."
  fi
fi
if [ -n "$(which udevadm 2>/dev/null)" ]; then
  echo "#T32: reload udev rules"
  udevadm control --reload 2>/dev/null
  udevadm control --reload-rules 2>/dev/null
  echo "#T32: Finished udev rules reload."
  echo "#T32: Please do not forget to toggle devices."
fi

exit 0
