; --------------------------------------------------------------------------------
; @Title: TRACE32 Semihosting using TRACE32 BUFFERE by overloading system calls
; @Description: 
;   TRACE32 Semihosting demo using stdio calls, t32term call, system call 
;    replacement and BUFFERE method
;   The script loads a sample application that executes a semihosting performance 
;   test by using stdio calls or T32_Term_* calls directly.
;   The stdio call are forwared to the T32_Term_ routines by replacing the system 
;   calls in (syscalls.c/retarget.c). T32_Term_* routines use the BUFFERE method 
;   to exchange data with the host while runtime.
;
;   The example is preconfigured for the GCC based example code. As this code is
;   position independent it can be used on every target platform.
;
;   Prerequisites:
;    * Adapt the variables 
;        &gcc_rambase & &gcc_datsize 
;      to match your target platform. SRAM recommended
;    * Connect to your CPU using SYStem.Mode.Up/SYStem.Mode.Attach
;
; @Props: Template
; @Keywords: Semihosting, Terminal
; @Author: AME, MAZ
; @Chip: Cortex-A*, Cortex-R*, Cortex-M*
; @Copyright: (C) 1989-2022 Lauterbach GmbH, licensed for use with TRACE32(R) only
; --------------------------------------------------------------------------------
; $Id: term_performance_demo.cmm 18850 2022-01-26 18:41:29Z bschroefel $

PRIVATE &gcc_rambase &gcc_datsize &buffere_access_class &buffersize &SetNewBUFSIZ &gcc &bufferbase

&gcc="1"                ;- "1": use gcc generated pic code for multiple architectures at variable position in memory.
                        ;  "0": use the executable compiled by DS5 compiler. You need to adapt term_performance_demo_ds5.bat
                        ;  and scatter.scat in order to compile the code for your architecture and memory location
&gcc_rambase=0x04000000 ;- base address to load pic code generated by gcc
&gcc_datsize=0x20000    ;- space for stack and heap of gcc pic code
;&SetNewBUFSIZ=0x1000   ;- override internal file buffer size used by stdio file

&buffere_access_class="E"  ;- debugger memory class to access the BUFFERE buffers while the CPU is running (E is routed to either AHB or AXI)
&buffersize=0x1010     ;- buffer size for BUFFERE communication buffers (0x1010 would allow to pass 4096 byte wide data buffers for file transafer)

IF INTERFACE.SIM()
(
  SYStem.CPU CortexA9
  SYStem.Mode.Up
)
IF !SYStem.Up()
(
  PRINT "Please connect to your CPU before executing this script!"
  ENDDO
)
IF STATE.RUN()
  Break.direct

;generate test pattern file
Data.PATTERN VM:0x0++0x1fffff
Data.SAVE.Binary ~~~~/dumpin.bin VM:0x0--0x1fffff
; change into the demo directory - make sure we find the files
CD "~~~~/"

WinCLEAR
; load the demo code into RAM
IF "&gcc"=="1"
(
  PRIVATE &codebase
  &codebase=&gcc_rambase+0x100 ; - assume vector at codebase were we don't want to place code to avoid vector catch
  DO ~~~~/load_term_performance_demo.cmm &codebase
  &bufferbase=&codebase+&gcc_datsize
)
ELSE
(
  PRIVATE &stackstart &file
  &file="term_performance_demo_ds5"
  Data.LOAD.Elf &file.axf 
  &stackstart=(ADDRESS.OFFSET(y.secend(\\&file\ARM_LIB_STACK))+1)&0xFFFFFFF0
  &bufferbase=(&stackstart+0x100)&0xFFFFFF00
)

; run till main
Go main
WAIT !STATE.RUN()

IF !sYmbol.EXIST(Term_Memory_Tar2HostBuffer)
(
  ;configure t32term_memory.c in case define T32_TERM_MEMORY_BLOCKED_SIZE was not set
  Var.set T32_Term_Memory_Tar2HostBuffer=&bufferbase
  Var.set T32_Term_Tar2HostBufferSize=&buffersize
  Var.set T32_Term_Memory_Host2TarBuffer=&bufferbase+&buffersize
  Var.set T32_Term_Host2TarBufferSize=&buffersize
)

;clear communication semaphores
Var.set T32_Term_Memory_Tar2HostBuffer[0..3]=0
Var.set T32_Term_Memory_Host2TarBuffer[0..3]=0

; enable Runtime Memory access
IF !INTERFACE.SIM()
  SYStem.MemAccess DAP
IF (Var.VALUE(T32_Term_Tar2HostBufferSize)>0x100)
(
  TERM.METHOD BufferE &buffere_access_class:Var.VALUE(T32_Term_Memory_Tar2HostBuffer)++(var.value(T32_Term_Tar2HostBufferSize)-1) &buffere_access_class:var.value(T32_Term_Memory_Host2TarBuffer)++(var.value(T32_Term_Host2TarBufferSize)-1)
)
ELSE
(
  TERM.METHOD BufferE &buffere_access_class:Var.VALUE(T32_Term_Memory_Tar2HostBuffer) &buffere_access_class:Var.VALUE(T32_Term_Memory_Host2TarBuffer)
)
TERM.MODE VT100

IF "&SetNewBUFSIZ"!=""
  Var.set newBUFSIZ=&SetNewBUFSIZ
Break.Set vFatal\1

&filesize=Var.VALUE(sizeof(pBuffer))*Var.VALUE(blockcount)/1024.

PRINT "target BUFFERE size " FORMAT.Decimal(0.,var.value(T32_Term_Tar2HostBufferSize))
PRINT "target block size " FORMAT.Decimal(0.,sYmbol.sizeof(pBuffer))
PRINT "target block count " FORMAT.Decimal(0.,var.value(blockcount))
PRINT "target file size " FORMAT.Decimal(0.,&filesize) " KBytes"

; open the TERM.GATE window - uses for Terminal/Semihosting
WinPOS 0% 0%
TERM.GATE
WinPOS 0% 80% 80. 12.
AREA

Mode.Hll
List.auto
LOCAL &yesno
DIALOG.YESNO "Do you want to start the test?"
ENTRY &yesno
IF !&yesno
  ENDDO

Break.Set vScenarioHook\1
Break.Set vReadTransferStartHook\1
Break.Set vReadTransferEndHook\1
Break.Set vWriteTransferStartHook\1
Break.Set vWriteTransferEndHook\1
Break.Set vTransferHook\1
Break.Set vFatal\1

GOSUB TestRun
GOSUB TestRun

ENDDO

; --------------------------------------------------------------------------------
; Subroutines

TestRun:
(
  PRIVATE &times
  GOSUB StartWaitTarget "vScenarioHook\1"
  Go.Up
  IF sYmbol.EXIST(pReadFile)
     PRINT "-------------------------- testing stdio system calls interface -----------------"
  IF sYmbol.EXIST(hReadFile)
     PRINT "-------------------------- testing TRACE32 terminal interface -------------------"
  GOSUB StartWaitTarget "vReadTransferStartHook\1"
  GOSUB StartWaitTarget "vReadTransferEndHook\1"
  RETURNVALUES &times
  GOSUB StartWaitTarget "vTransferHook\1"
  PRINT "Transfer of " FORMAT.DECimal(0.,&filesize) " KBytes from Host to Target took " FORMAT.DECimal(0.,&times) " seconds."
  GOSUB StartWaitTarget "vWriteTransferStartHook\1"
  GOSUB StartWaitTarget "vWriteTransferEndHook\1"
  RETURNVALUES &times
  GOSUB StartWaitTarget "vTransferHook\1"
  PRINT "Transfer of " FORMAT.DECimal(0.,&filesize) " KBytes from Target to Host took " FORMAT.DECimal(0.,&times) " seconds."
  RETURN
)

; --------------------------------------------------------------------------------

StartWaitTarget:
(
  PARAMETERS &symbolname
  PRIVATE &starttime &stoptime &time
  &starttime=DATE.UnixTime()
  Go.direct
  WAIT !STATE.RUN()
  &stoptime=DATE.UnixTime()
  if "&symbolname"!="" 
    GOSUB VerifyHook "&symbolname"
  &time=&stoptime-&starttime
  RETURN "&time"
)

; --------------------------------------------------------------------------------

VerifyHook:
(
  PARAMETERS &symbolname
  IF Register(PC)!=ADDRESS.OFFSET(&symbolname)
  (
    PRINT "Error"
    ENDDO
  )
  RETURN
)
